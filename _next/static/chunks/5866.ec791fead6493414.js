"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5866],{15866:function(t,e,n){let r;n.d(e,{$3:function(){return getPublicKey},E9:function(){return Point},P6:function(){return B},T:function(){return verify},Xx:function(){return sign},Z_:function(){return p}});var o,i=n(7420);/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */let s=BigInt(0),f=BigInt(1),d=BigInt(2),a=BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),u=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l:a,n:a,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),l=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),c=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");let m=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),y=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),h=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),E=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");let ExtendedPoint=class ExtendedPoint{constructor(t,e,n,r){this.x=t,this.y=e,this.z=n,this.t=r}static fromAffine(t){if(!(t instanceof Point))throw TypeError("ExtendedPoint#fromAffine: expected Point");return t.equals(Point.ZERO)?ExtendedPoint.ZERO:new ExtendedPoint(t.x,t.y,f,mod(t.x*t.y))}static toAffineBatch(t){let e=function(t,e=u.P){let n=Array(t.length),r=t.reduce((t,r,o)=>r===s?t:(n[o]=t,mod(t*r,e)),f),o=invert(r,e);return t.reduceRight((t,r,o)=>r===s?t:(n[o]=mod(t*n[o],e),mod(t*r,e)),o),n}(t.map(t=>t.z));return t.map((t,n)=>t.toAffine(e[n]))}static normalizeZ(t){return this.toAffineBatch(t).map(this.fromAffine)}equals(t){assertExtPoint(t);let{x:e,y:n,z:r}=this,{x:o,y:i,z:s}=t,f=mod(e*s),d=mod(o*r),a=mod(n*s),u=mod(i*r);return f===d&&a===u}negate(){return new ExtendedPoint(mod(-this.x),this.y,this.z,mod(-this.t))}double(){let{x:t,y:e,z:n}=this,{a:r}=u,o=mod(t*t),i=mod(e*e),s=mod(d*mod(n*n)),f=mod(r*o),a=t+e,l=mod(mod(a*a)-o-i),c=f+i,m=c-s,y=f-i,h=mod(l*m),E=mod(c*y),x=mod(l*y),w=mod(m*c);return new ExtendedPoint(h,E,w,x)}add(t){assertExtPoint(t);let{x:e,y:n,z:r,t:o}=this,{x:i,y:f,z:a,t:u}=t,l=mod((n-e)*(f+i)),c=mod((n+e)*(f-i)),m=mod(c-l);if(m===s)return this.double();let y=mod(r*d*u),h=mod(o*d*a),E=h+y,x=c+l,w=h-y,g=mod(E*m),p=mod(x*w),P=mod(E*w),B=mod(m*x);return new ExtendedPoint(g,p,B,P)}subtract(t){return this.add(t.negate())}precomputeWindow(t){let e=1+256/t,n=[],r=this,o=r;for(let i=0;i<e;i++){o=r,n.push(o);for(let e=1;e<2**(t-1);e++)o=o.add(r),n.push(o);r=o.double()}return n}wNAF(t,e){!e&&this.equals(ExtendedPoint.BASE)&&(e=Point.BASE);let n=e&&e._WINDOW_SIZE||1;if(256%n)throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&x.get(e);!r&&(r=this.precomputeWindow(n),e&&1!==n&&(r=ExtendedPoint.normalizeZ(r),x.set(e,r)));let o=ExtendedPoint.ZERO,i=ExtendedPoint.ZERO,s=1+256/n,d=2**(n-1),a=BigInt(2**n-1),u=2**n,l=BigInt(n);for(let e=0;e<s;e++){let n=e*d,s=Number(t&a);if(t>>=l,s>d&&(s-=u,t+=f),0===s){let t=r[n];e%2&&(t=t.negate()),i=i.add(t)}else{let t=r[n+Math.abs(s)-1];s<0&&(t=t.negate()),o=o.add(t)}}return ExtendedPoint.normalizeZ([o,i])[0]}multiply(t,e){return this.wNAF(normalizeScalar(t,u.l),e)}multiplyUnsafe(t){let e=normalizeScalar(t,u.l,!1),n=ExtendedPoint.BASE,r=ExtendedPoint.ZERO;if(e===s)return r;if(this.equals(r)||e===f)return this;if(this.equals(n))return this.wNAF(e);let o=r,i=this;for(;e>s;)e&f&&(o=o.add(i)),i=i.double(),e>>=f;return o}isSmallOrder(){return this.multiplyUnsafe(u.h).equals(ExtendedPoint.ZERO)}isTorsionFree(){return this.multiplyUnsafe(u.l).equals(ExtendedPoint.ZERO)}toAffine(t=invert(this.z)){let{x:e,y:n,z:r}=this,o=mod(e*t),i=mod(n*t),s=mod(r*t);if(s!==f)throw Error("invZ was invalid");return new Point(o,i)}fromRistrettoBytes(){legacyRist()}toRistrettoBytes(){legacyRist()}fromRistrettoHash(){legacyRist()}};function assertExtPoint(t){if(!(t instanceof ExtendedPoint))throw TypeError("ExtendedPoint expected")}function assertRstPoint(t){if(!(t instanceof RistrettoPoint))throw TypeError("RistrettoPoint expected")}function legacyRist(){throw Error("Legacy method: switch to RistrettoPoint")}ExtendedPoint.BASE=new ExtendedPoint(u.Gx,u.Gy,f,mod(u.Gx*u.Gy)),ExtendedPoint.ZERO=new ExtendedPoint(s,f,f,s);let RistrettoPoint=class RistrettoPoint{constructor(t){this.ep=t}static calcElligatorRistrettoMap(t){let{d:e}=u,n=mod(c*t*t),r=mod((n+f)*h),o=BigInt(-1),i=mod((o-e*n)*mod(n+e)),{isValid:s,value:d}=uvRatio(r,i),a=mod(d*t);edIsNegative(a)||(a=mod(-a)),s||(d=a),s||(o=n);let l=mod(o*(n-f)*E-i),y=d*d,x=mod((d+d)*i),w=mod(l*m),g=mod(f-y),p=mod(f+y);return new ExtendedPoint(mod(x*p),mod(g*w),mod(w*p),mod(x*g))}static hashToCurve(t){t=ensureBytes(t,64);let e=bytes255ToNumberLE(t.slice(0,32)),n=this.calcElligatorRistrettoMap(e),r=bytes255ToNumberLE(t.slice(32,64)),o=this.calcElligatorRistrettoMap(r);return new RistrettoPoint(n.add(o))}static fromHex(t){var e;t=ensureBytes(t,32);let{a:n,d:r}=u,o="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",i=bytes255ToNumberLE(t);if(!function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}(numberTo32BytesLE(i),t)||edIsNegative(i))throw Error(o);let d=mod(i*i),a=mod(f+n*d),l=mod(f-n*d),c=mod(a*a),m=mod(l*l),y=mod(n*r*c-m),{isValid:h,value:E}=uvRatio(f,mod(y*m)),x=mod(E*l),w=mod(E*x*y),g=mod((i+i)*x);edIsNegative(g)&&(g=mod(-g));let p=mod(a*w),P=mod(g*p);if(!h||edIsNegative(P)||p===s)throw Error(o);return new RistrettoPoint(new ExtendedPoint(g,p,f,P))}toRawBytes(){var t;let e,{x:n,y:r,z:o,t:i}=this.ep,s=mod(mod(o+r)*mod(o-r)),d=mod(n*r),a=mod(d*d),{value:u}=uvRatio(f,mod(s*a)),l=mod(u*s),m=mod(u*d),h=mod(l*m*i);if(edIsNegative(i*h)){let t=mod(r*c),o=mod(n*c);n=t,r=o,e=mod(l*y)}else e=m;edIsNegative(n*h)&&(r=mod(-r));let E=mod((o-r)*e);return edIsNegative(E)&&(E=mod(-E)),numberTo32BytesLE(E)}toHex(){return bytesToHex(this.toRawBytes())}toString(){return this.toHex()}equals(t){assertRstPoint(t);let e=this.ep,n=t.ep,r=mod(e.x*n.y)===mod(e.y*n.x),o=mod(e.y*n.y)===mod(e.x*n.x);return r||o}add(t){return assertRstPoint(t),new RistrettoPoint(this.ep.add(t.ep))}subtract(t){return assertRstPoint(t),new RistrettoPoint(this.ep.subtract(t.ep))}multiply(t){return new RistrettoPoint(this.ep.multiply(t))}multiplyUnsafe(t){return new RistrettoPoint(this.ep.multiplyUnsafe(t))}};RistrettoPoint.BASE=new RistrettoPoint(ExtendedPoint.BASE),RistrettoPoint.ZERO=new RistrettoPoint(ExtendedPoint.ZERO);let x=new WeakMap;let Point=class Point{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,x.delete(this)}static fromHex(t,e=!0){let{d:n,P:r}=u;t=ensureBytes(t,32);let o=t.slice();o[31]=-129&t[31];let i=bytesToNumberLE(o);if(e&&i>=r)throw Error("Expected 0 < hex < P");if(!e&&i>=l)throw Error("Expected 0 < hex < 2**256");let s=mod(i*i),d=mod(s-f),a=mod(n*s+f),{isValid:c,value:m}=uvRatio(d,a);if(!c)throw Error("Point.fromHex: invalid y coordinate");let y=(m&f)===f,h=(128&t[31])!=0;return h!==y&&(m=mod(-m)),new Point(m,i)}static async fromPrivateKey(t){return(await getExtendedPublicKey(t)).point}toRawBytes(){let t=numberTo32BytesLE(this.y);return t[31]|=this.x&f?128:0,t}toHex(){return bytesToHex(this.toRawBytes())}toX25519(){let{y:t}=this,e=mod((f+t)*invert(f-t));return numberTo32BytesLE(e)}isTorsionFree(){return ExtendedPoint.fromAffine(this).isTorsionFree()}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new Point(mod(-this.x),this.y)}add(t){return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return ExtendedPoint.fromAffine(this).multiply(t,this).toAffine()}};Point.BASE=new Point(u.Gx,u.Gy),Point.ZERO=new Point(s,f);let Signature=class Signature{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){let e=ensureBytes(t,64),n=Point.fromHex(e.slice(0,32),!1),r=bytesToNumberLE(e.slice(32,64));return new Signature(n,r)}assertValidity(){let{r:t,s:e}=this;if(!(t instanceof Point))throw Error("Expected Point instance");return normalizeScalar(e,u.l,!1),this}toRawBytes(){let t=new Uint8Array(64);return t.set(this.r.toRawBytes()),t.set(numberTo32BytesLE(this.s),32),t}toHex(){return bytesToHex(this.toRawBytes())}};function concatBytes(...t){if(!t.every(t=>t instanceof Uint8Array))throw Error("Expected Uint8Array list");if(1===t.length)return t[0];let e=t.reduce((t,e)=>t+e.length,0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){let o=t[e];n.set(o,r),r+=o.length}return n}let w=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex(t){if(!(t instanceof Uint8Array))throw Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=w[t[n]];return e}function hexToBytes(t){if("string"!=typeof t)throw TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw Error("hexToBytes: received invalid unpadded hex");let e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){let r=2*n,o=t.slice(r,r+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw Error("Invalid byte sequence");e[n]=i}return e}function numberTo32BytesBE(t){let e=t.toString(16).padStart(64,"0");return hexToBytes(e)}function numberTo32BytesLE(t){return numberTo32BytesBE(t).reverse()}function edIsNegative(t){return(mod(t)&f)===f}function bytesToNumberLE(t){if(!(t instanceof Uint8Array))throw Error("Expected Uint8Array");return BigInt("0x"+bytesToHex(Uint8Array.from(t).reverse()))}let g=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function bytes255ToNumberLE(t){return mod(bytesToNumberLE(t)&g)}function mod(t,e=u.P){let n=t%e;return n>=s?n:e+n}function invert(t,e=u.P){if(t===s||e<=s)throw Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=mod(t,e),r=e,o=s,i=f,d=f,a=s;for(;n!==s;){let t=r/n,e=r%n,s=o-d*t,f=i-a*t;r=n,n=e,o=d,i=a,d=s,a=f}let l=r;if(l!==f)throw Error("invert: does not exist");return mod(o,e)}function pow2(t,e){let{P:n}=u,r=t;for(;e-- >s;)r*=r,r%=n;return r}function uvRatio(t,e){let n=mod(e*e*e),r=mod(n*n*e),o=function(t){let{P:e}=u,n=BigInt(5),r=BigInt(10),o=BigInt(20),i=BigInt(40),s=BigInt(80),a=t*t%e*t%e,l=pow2(a,d)*a%e,c=pow2(l,f)*t%e,m=pow2(c,n)*c%e,y=pow2(m,r)*m%e,h=pow2(y,o)*y%e,E=pow2(h,i)*h%e,x=pow2(E,s)*E%e,w=pow2(x,s)*E%e,g=pow2(w,r)*m%e,p=pow2(g,d)*t%e;return{pow_p_5_8:p,b2:a}}(t*r).pow_p_5_8,i=mod(t*n*o),s=mod(e*i*i),a=i,l=mod(i*c),m=s===t,y=s===mod(-t),h=s===mod(-t*c);return m&&(i=a),(y||h)&&(i=l),edIsNegative(i)&&(i=mod(-i)),{isValid:m||y,value:i}}function modlLE(t){return mod(bytesToNumberLE(t),u.l)}function ensureBytes(t,e){let n=t instanceof Uint8Array?Uint8Array.from(t):hexToBytes(t);if("number"==typeof e&&n.length!==e)throw Error(`Expected ${e} bytes`);return n}function normalizeScalar(t,e,n=!0){if(!e)throw TypeError("Specify max value");if("number"==typeof t&&Number.isSafeInteger(t)&&(t=BigInt(t)),"bigint"==typeof t&&t<e){if(n){if(s<t)return t}else if(s<=t)return t}throw TypeError("Expected valid scalar: 0 < scalar < max")}function checkPrivateKey(t){if(32!==(t="bigint"==typeof t||"number"==typeof t?numberTo32BytesBE(normalizeScalar(t,l)):ensureBytes(t)).length)throw Error("Expected 32 bytes");return t}function getKeyFromHash(t){var e;let n=(e=t.slice(0,32),e[0]&=248,e[31]&=127,e[31]|=64,e),r=t.slice(32,64),o=modlLE(n),i=Point.BASE.multiply(o),s=i.toRawBytes();return{head:n,prefix:r,scalar:o,point:i,pointBytes:s}}function sha512s(...t){if("function"!=typeof r)throw Error("utils.sha512Sync must be set to use sync methods");return r(...t)}async function getExtendedPublicKey(t){return getKeyFromHash(await B.sha512(checkPrivateKey(t)))}function getExtendedPublicKeySync(t){return getKeyFromHash(sha512s(checkPrivateKey(t)))}async function getPublicKey(t){return(await getExtendedPublicKey(t)).pointBytes}async function sign(t,e){t=ensureBytes(t);let{prefix:n,scalar:r,pointBytes:o}=await getExtendedPublicKey(e),i=modlLE(await B.sha512(n,t)),s=Point.BASE.multiply(i),f=modlLE(await B.sha512(s.toRawBytes(),o,t)),d=mod(i+f*r,u.l);return new Signature(s,d).toRawBytes()}function prepareVerification(t,e,n){e=ensureBytes(e),n instanceof Point||(n=Point.fromHex(n,!1));let{r,s:o}=t instanceof Signature?t.assertValidity():Signature.fromHex(t),i=ExtendedPoint.BASE.multiplyUnsafe(o);return{r,s:o,SB:i,pub:n,msg:e}}function finishVerification(t,e,n,r){let o=modlLE(r),i=ExtendedPoint.fromAffine(t).multiplyUnsafe(o),s=ExtendedPoint.fromAffine(e).add(i);return s.subtract(n).multiplyUnsafe(u.h).equals(ExtendedPoint.ZERO)}async function verify(t,e,n){let{r,SB:o,msg:i,pub:s}=prepareVerification(t,e,n),f=await B.sha512(r.toRawBytes(),s.toRawBytes(),i);return finishVerification(s,r,o,f)}let p={getExtendedPublicKey:getExtendedPublicKeySync,getPublicKey:function(t){return getExtendedPublicKeySync(t).pointBytes},sign:function(t,e){t=ensureBytes(t);let{prefix:n,scalar:r,pointBytes:o}=getExtendedPublicKeySync(e),i=modlLE(sha512s(n,t)),s=Point.BASE.multiply(i),f=modlLE(sha512s(s.toRawBytes(),o,t)),d=mod(i+f*r,u.l);return new Signature(s,d).toRawBytes()},verify:function(t,e,n){let{r,SB:o,msg:i,pub:s}=prepareVerification(t,e,n),f=sha512s(r.toRawBytes(),s.toRawBytes(),i);return finishVerification(s,r,o,f)}};Point.BASE._setWindowSize(8);let P={node:o||(o=n.t(i,2)),web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},B={bytesToHex,hexToBytes,concatBytes,getExtendedPublicKey,mod,invert,TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],hashToPrivateScalar:t=>{if((t=ensureBytes(t)).length<40||t.length>1024)throw Error("Expected 40-1024 bytes of private key as per FIPS 186");return mod(bytesToNumberLE(t),u.l-f)+f},randomBytes:(t=32)=>{if(P.web)return P.web.getRandomValues(new Uint8Array(t));if(P.node){let{randomBytes:e}=P.node;return new Uint8Array(e(t).buffer)}throw Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>B.randomBytes(32),sha512:async(...t)=>{let e=concatBytes(...t);if(P.web){let t=await P.web.subtle.digest("SHA-512",e.buffer);return new Uint8Array(t)}if(P.node)return Uint8Array.from(P.node.createHash("sha512").update(e).digest());throw Error("The environment doesn't have sha512 function")},precompute(t=8,e=Point.BASE){let n=e.equals(Point.BASE)?e:new Point(e.x,e.y);return n._setWindowSize(t),n.multiply(d),n},sha512Sync:void 0};Object.defineProperties(B,{sha512Sync:{configurable:!1,get:()=>r,set(t){r||(r=t)}}})}}]);
//# sourceMappingURL=5866.ec791fead6493414.js.map