{"version":3,"file":"static/chunks/5866.ec791fead6493414.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@noble/ed25519/lib/esm/index.js","webpack://_N_E/<anon>"],"sourcesContent":["/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\nconst CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n    l: CU_O,\n    n: CU_O,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n});\nexport { CURVE };\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(_2n * mod(Z1 * Z1));\n        const D = mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = mod(mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.ZERO;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= POW_2_256)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexport { ExtendedPoint, RistrettoPoint, Point, Signature };\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, POW_2_256))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    return key;\n}\nfunction getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n    if (typeof _sha512Sync !== 'function')\n        throw new Error('utils.sha512Sync must be set to use sync methods');\n    return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nexport async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nfunction getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nexport async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return { r, s, SB, pub: publicKey, msg: message };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexport async function verify(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nfunction verifySync(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nexport const sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync,\n};\nexport async function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        const dacb = DA + CB;\n        const da_cb = DA - CB;\n        x_3 = mod(dacb * dacb);\n        z_3 = mod(x_1 * mod(da_cb * da_cb));\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexport const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (...messages) => {\n        const message = concatBytes(...messages);\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n    sha512Sync: undefined,\n};\nObject.defineProperties(utils, {\n    sha512Sync: {\n        configurable: false,\n        get() {\n            return _sha512Sync;\n        },\n        set(val) {\n            if (!_sha512Sync)\n                _sha512Sync = val;\n        },\n    },\n});\n"],"names":["_sha512Sync","_0n","BigInt","_1n","_2n","CU_O","CURVE","Object","freeze","a","d","P","l","n","h","Gx","Gy","POW_2_256","SQRT_M1","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","ExtendedPoint","constructor","x","y","z","t","fromAffine","p","Point","equals","ZERO","mod","toAffineBatch","points","toInv","invertBatch","nums","tmp","length","lastMultiplied","reduce","acc","num","i","inverted","invert","reduceRight","map","toAffine","normalizeZ","other","assertExtPoint","X1","Y1","Z1","X2","Y2","Z2","X1Z2","X2Z1","Y1Z2","Y2Z1","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","multiply","scalar","normalizeScalar","multiplyUnsafe","P0","isSmallOrder","isTorsionFree","invZ","ax","ay","zz","fromRistrettoBytes","legacyRist","toRistrettoBytes","fromRistrettoHash","assertRstPoint","RistrettoPoint","ep","calcElligatorRistrettoMap","r0","r","Ns","c","isValid","Ns_D_is_sq","value","s","uvRatio","s_","edIsNegative","Nt","s2","W0","W1","W2","W3","hashToCurve","hex","ensureBytes","r1","bytes255ToNumberLE","slice","R1","r2","R2","fromHex","number","emsg","equalBytes","b1","b2","numberTo32BytesLE","u1","u2","u1_2","u2_2","v","I","Dx","Dy","toRawBytes","u2sq","invsqrt","D1","D2","zInv","_x","_y","toHex","bytesToHex","toString","b","one","two","WeakMap","_setWindowSize","delete","strict","normed","bytesToNumberLE","y2","u","isXOdd","isLastByteOdd","fromPrivateKey","privateKey","getExtendedPublicKey","point","bytes","toX25519","Signature","assertValidity","u8","Uint8Array","concatBytes","arrays","every","arr","result","pad","hexes","Array","from","padStart","uint8a","hexToBytes","array","j","hexByte","byte","parseInt","isNaN","numberTo32BytesBE","reverse","MAX_255B","res","modulo","q","m","gcd","pow2","power","v3","v7","pow","pow_2_252_3","_5n","_10n","_20n","_40n","_80n","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","vx2","root1","root2","useRoot1","useRoot2","noRoot","modlLE","hash","expectedLength","max","isSafeInteger","checkPrivateKey","key","getKeyFromHash","hashed","head","prefix","pointBytes","sha512s","utils","sha512","getExtendedPublicKeySync","getPublicKey","sign","message","R","k","prepareVerification","sig","publicKey","SB","pub","msg","finishVerification","kA","RkA","verify","sync","crypto","node","crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache","__webpack_require__","crypto__WEBPACK_IMPORTED_MODULE_0__","web","self","undefined","TORSION_SUBGROUP","hashToPrivateScalar","randomBytes","bytesLength","getRandomValues","buffer","randomPrivateKey","messages","subtle","digest","createHash","update","precompute","sha512Sync","defineProperties","configurable","val"],"sourceRoot":""}