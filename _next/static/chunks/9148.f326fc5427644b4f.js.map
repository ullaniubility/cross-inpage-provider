{"version":3,"file":"static/chunks/9148.f326fc5427644b4f.js","mappings":"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","sources":["webpack://_N_E/./node_modules/base-x/src/index.js","webpack://_N_E/./node_modules/safe-buffer/index.js","webpack://_N_E/./node_modules/@onekeyfe/extension-bridge-injected/dist/JsBridgeExtInjected.js","webpack://_N_E/./node_modules/@onekeyfe/extension-bridge-injected/dist/index.js","webpack://_N_E/./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs","webpack://_N_E/<anon>"],"sourcesContent":["'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport { fakeDebugLogger, consts } from '@onekeyfe/cross-inpage-provider-core';\nimport { JsBridgeBase, injectedProviderReceiveHandler, injectJsBridge, } from '@onekeyfe/cross-inpage-provider-core';\nconst { JS_BRIDGE_MESSAGE_DIRECTION, JS_BRIDGE_MESSAGE_EXT_CHANNEL } = consts;\nfunction getOrCreateExtInjectedJsBridge(options = {}) {\n    // create ext bridge by default\n    const bridgeCreator = () => new JsBridgeExtInjected(Object.assign(Object.assign({}, options), { receiveHandler: injectedProviderReceiveHandler }));\n    const bridge = injectJsBridge(bridgeCreator);\n    return bridge;\n}\nlet postMessageListenerAdded = false;\nfunction setupPostMessageListener(options = {}) {\n    const debugLogger = options.debugLogger || fakeDebugLogger;\n    if (postMessageListenerAdded) {\n        return;\n    }\n    postMessageListenerAdded = true;\n    // - receive\n    // #### content-script -> injected\n    window.addEventListener('message', (event) => {\n        var _a, _b;\n        // We only accept messages from ourselves\n        if (event.source !== window) {\n            return;\n        }\n        const eventData = event.data;\n        // only accept extension messages\n        if (eventData.channel === JS_BRIDGE_MESSAGE_EXT_CHANNEL &&\n            eventData.direction === JS_BRIDGE_MESSAGE_DIRECTION.HOST_TO_INPAGE) {\n            debugLogger.extInjected('onWindowPostMessage', eventData);\n            const payload = eventData.payload;\n            const jsBridge = (_a = options.bridge) !== null && _a !== void 0 ? _a : (_b = window === null || window === void 0 ? void 0 : window.$onekey) === null || _b === void 0 ? void 0 : _b.jsBridge;\n            if (jsBridge) {\n                jsBridge.receive(payload);\n            }\n        }\n    }, false);\n}\nclass JsBridgeExtInjected extends JsBridgeBase {\n    constructor(config) {\n        super(config);\n        this.sendAsString = false;\n        this.isInjected = true;\n        // receive message\n        setupPostMessageListener({\n            debugLogger: this.debugLogger,\n            bridge: this,\n        });\n    }\n    // send message\n    sendPayload(payloadObj) {\n        window.postMessage({\n            channel: JS_BRIDGE_MESSAGE_EXT_CHANNEL,\n            direction: JS_BRIDGE_MESSAGE_DIRECTION.INPAGE_TO_HOST,\n            payload: payloadObj,\n        });\n    }\n}\nexport { JsBridgeExtInjected, getOrCreateExtInjectedJsBridge };\n","export * from './JsBridgeExtInjected';\n","'use strict';\n\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = string.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n                               (cp & 0x3FF) + 0xDC00);\n    }\n  }\n  return s;\n}\n\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 3. Terminology\n//\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the\n * stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n   read: function() {\n    if (!this.tokens.length)\n      return end_of_stream;\n     return this.tokens.shift();\n   },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.unshift(tokens.pop());\n    } else {\n      this.tokens.unshift(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.push(tokens.shift());\n    } else {\n      this.tokens.push(token);\n    }\n  }\n};\n\n//\n// 4. Encodings\n//\n\n// 4.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error');\n  return opt_code_point || 0xFFFD;\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function(stream, code_point) {}\n};\n\n//\n// 7. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 7.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(encoding, options) {\n  if (!(this instanceof TextDecoder)) {\n    return new TextDecoder(encoding, options);\n  }\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._fatal = Boolean(options['fatal']);\n  /** @private @type {boolean} */\n  this._ignoreBOM = Boolean(options['ignoreBOM']);\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n  Object.defineProperty(this, 'fatal', {value: this._fatal});\n  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});\n}\n\nTextDecoder.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    if (!this._streaming) {\n      this._decoder = new UTF8Decoder({fatal: this._fatal});\n      this._BOMseen = false;\n    }\n    this._streaming = Boolean(options['stream']);\n\n    var input_stream = new Stream(bytes);\n\n    var code_points = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    while (!input_stream.endOfStream()) {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (result === null)\n        continue;\n      if (Array.isArray(result))\n        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n      else\n        code_points.push(result);\n    }\n    if (!this._streaming) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n        else\n          code_points.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    if (code_points.length) {\n      // If encoding is one of utf-8, utf-16be, and utf-16le, and\n      // ignore BOM flag and BOM seen flag are unset, run these\n      // subsubsteps:\n      if (['utf-8'].indexOf(this.encoding) !== -1 &&\n          !this._ignoreBOM && !this._BOMseen) {\n        // If token is U+FEFF, set BOM seen flag.\n        if (code_points[0] === 0xFEFF) {\n          this._BOMseen = true;\n          code_points.shift();\n        } else {\n          // Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to output.\n          this._BOMseen = true;\n        }\n      }\n    }\n\n    return codePointsToString(code_points);\n  }\n};\n\n// 7.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextEncoder(encoding, options) {\n  if (!(this instanceof TextEncoder))\n    return new TextEncoder(encoding, options);\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n  /** @private @type {{fatal: boolean}} */\n  this._options = {fatal: Boolean(options['fatal'])};\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n}\n\nTextEncoder.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : '';\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,\n    // so streaming is not necessary.\n    if (!this._streaming)\n      this._encoder = new UTF8Encoder(this._options);\n    this._streaming = Boolean(options['stream']);\n\n    var bytes = [];\n    var input_stream = new Stream(stringToCodePoints(opt_string));\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    while (!input_stream.endOfStream()) {\n      result = this._encoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n      else\n        bytes.push(result);\n    }\n    if (!this._streaming) {\n      while (true) {\n        result = this._encoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n        else\n          bytes.push(result);\n      }\n      this._encoder = null;\n    }\n    return new Uint8Array(bytes);\n  }\n};\n\n//\n// 8. The encoding\n//\n\n// 8.1 utf-8\n\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7F)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      if (inRange(bite, 0xC2, 0xDF)) {\n        // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n        // − 0xC0.\n        utf8_bytes_needed = 1;\n        utf8_code_point = bite - 0xC0;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xE0, 0xEF)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xE0)\n          utf8_lower_boundary = 0xA0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xED)\n          utf8_upper_boundary = 0x9F;\n        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n        // byte − 0xE0.\n        utf8_bytes_needed = 2;\n        utf8_code_point = bite - 0xE0;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xF0, 0xF4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xF0)\n          utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xF4)\n          utf8_upper_boundary = 0x8F;\n        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n        // byte − 0xF0.\n        utf8_bytes_needed = 3;\n        utf8_code_point = bite - 0xF0;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code\n      // point to utf-8 code point << (6 × utf-8 bytes needed) and\n      // return continue.\n      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xBF;\n\n    // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n    // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes\n    // needed − utf-8 bytes seen)).\n    utf8_bytes_seen += 1;\n    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));\n\n    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed)\n      return null;\n\n    // 8. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 10. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished;\n\n    // 2. If code point is in the range U+0000 to U+007F, return a\n    // byte whose value is code point.\n    if (inRange(code_point, 0x0000, 0x007f))\n      return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF:    1 and 0xC0\n    if (inRange(code_point, 0x0080, 0x07FF)) {\n      count = 1;\n      offset = 0xC0;\n    }\n    // U+0800 to U+FFFF:    2 and 0xE0\n    else if (inRange(code_point, 0x0800, 0xFFFF)) {\n      count = 2;\n      offset = 0xE0;\n    }\n    // U+10000 to U+10FFFF: 3 and 0xF0\n    else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n      count = 3;\n      offset = 0xF0;\n    }\n\n    // 4.Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3F));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\nexport {TextEncoder, TextDecoder};\n"],"names":["_Buffer","__webpack_require__","Buffer","module","exports","ALPHABET","length","BASE_MAP","Uint8Array","j","i","x","charAt","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","alloc","psz","zeroes","size","b256","carry","it3","it4","vch","allocUnsafe","fill","encode","Array","isArray","from","isBuffer","pbegin","pend","b58","it1","it2","str","repeat","decode","string","buffer","copyProps","src","dst","key","SafeBuffer","arg","encodingOrOffset","allocUnsafeSlow","prototype","Object","create","encoding","buf","undefined","SlowBuffer","JS_BRIDGE_MESSAGE_DIRECTION","JS_BRIDGE_MESSAGE_EXT_CHANNEL","dist","consts","getOrCreateExtInjectedJsBridge","options","bridge","Pk","JsBridgeExtInjected","assign","receiveHandler","gZ","postMessageListenerAdded","ZN","constructor","config","sendAsString","isInjected","setupPostMessageListener","debugLogger","go","window","addEventListener","_a","_b","event","eventData","data","channel","direction","HOST_TO_INPAGE","extInjected","payload","jsBridge","$onekey","receive","sendPayload","payloadObj","postMessage","INPAGE_TO_HOST","inRange","a","min","max","ToDictionary","o","TypeError","Stream","tokens","slice","call","decoderError","fatal","opt_code_point","endOfStream","read","shift","prepend","token","unshift","pop","push","DEFAULT_ENCODING","TextDecoder","String","toLowerCase","_streaming","_BOMseen","_decoder","_fatal","Boolean","_ignoreBOM","defineProperty","value","TextEncoder","_encoder","_options","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","handler","stream","bite","code_point","UTF8Encoder","count","offset","bytes","temp","input","ArrayBuffer","byteOffset","byteLength","result","input_stream","code_points","apply","indexOf","codePointsToString","s","cp","fromCharCode","opt_string","stringToCodePoints","n","u","c","d","b"],"sourceRoot":""}